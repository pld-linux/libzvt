Index: libzvt/.cvsignore
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/.cvsignore,v
retrieving revision 1.5
retrieving revision 1.4.2.1
diff -u -r1.5 -r1.4.2.1
Index: libzvt/Makefile.am
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/Makefile.am,v
retrieving revision 1.61
retrieving revision 1.59.2.3
diff -u -r1.61 -r1.59.2.3
--- libzvt/Makefile.am	19 Jun 2002 18:53:58 -0000	1.61
+++ libzvt/Makefile.am	2 Aug 2002 01:58:16 -0000	1.59.2.3
@@ -22,7 +22,8 @@
 	-DG_DISABLE_DEPRECATED		\
 	-DGDK_DISABLE_DEPRECATED	\
 	-DGDK_PIXBUF_DISABLE_DEPRECATED \
-	-DGTK_DISABLE_DEPRECATED
+	-DGTK_DISABLE_DEPRECATED	\
+	-DHAS_I18N
 
 libzvt_2_includedir = $(includedir)/libzvt-2.0/libzvt
 

Index: libzvt/gnome-pty-helper.c
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/gnome-pty-helper.c,v
retrieving revision 1.59
retrieving revision 1.57.2.1
diff -u -r1.59 -r1.57.2.1
Index: libzvt/libzvt-2.0.pc.in
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/libzvt-2.0.pc.in,v
retrieving revision 1.7
retrieving revision 1.6.2.1
diff -u -r1.7 -r1.6.2.1
Index: libzvt/libzvt.h
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/libzvt.h,v
retrieving revision 1.15
retrieving revision 1.14.2.3
diff -u -r1.15 -r1.14.2.3
--- libzvt/libzvt.h	3 Jun 2002 16:59:26 -0000	1.15
+++ libzvt/libzvt.h	2 Aug 2002 01:58:16 -0000	1.14.2.3
@@ -17,6 +17,28 @@
  *  License along with this program; if not, write to the Free Software
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
+/*
+  I18N codes are added by
+	Naoyuki Ishimura <naoyuki.ishimura@sun.com>
+	Hidetoshi Tajima <hidetoshi.tajima@sun.com>
+
+   Copyright (C) 2002 Sun Microsystems, Inc.
+
+   The Gnome Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The Gnome Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the Gnome Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
 #ifndef LIBZVT_H
 #define LIBZVT_H
 
@@ -37,6 +59,11 @@
 #include <gtk/gtkadjustment.h>
 #include <gtk/gtkwidget.h>
 #include <gtk/gtksignal.h>
+#ifdef HAS_I18N
+#include <X11/Xlib.h>
+#include <gtk/gtkimcontext.h>
+extern gint vt_column_from_utf8(gchar *, gint);
+#endif
 #include <libzvt/vtx.h>
 #include <libzvt/background.h>
 
@@ -121,6 +148,13 @@
   GdkColor colors [18];		/* GdkColor for colormap support */
   /* GdkIC depecated, needto be substituted with GtkIMContext, not yet done */
   /* GdkIC *ic;*/		/* input context */
+#ifdef HAS_I18N
+  /* input context */
+  GtkIMContext *ic;
+  gboolean need_im_reset;
+  XFontSet xfontset;
+  int font_ascent;
+#endif  
 
  /* file name of a pixmap, if NULL, none is loaded
   * and normal mode is used
@@ -210,6 +244,13 @@
   unsigned short *queue_red, *queue_green, *queue_blue;
 
   char auto_hint;		/* when 1, we automatically set window manager size hints */
+
+#ifdef HAS_I18N
+  PangoContext *pango_context;
+  PangoFontDescription *pango_font;
+  PangoFontDescription *pango_font_bold;
+  GdkWindow *preedit_window;
+#endif /* HAS_I18N */  
 };
 
 /* *** DO NOT USE THIS IN APPS! *** */
@@ -240,7 +281,13 @@
 						int type,
 						int sx, int sy,
 						int ex, int ey);
+#ifdef HAS_I18N
+void         zvt_term_set_pango_font            (ZvtTerm *term,
+						 const PangoFontDescription*);
+#endif
 void         zvt_term_set_font_name            (ZvtTerm *term, char *name);
+
+
 void         zvt_term_set_fonts                (ZvtTerm *term,
 						GdkFont *font,
 						GdkFont *font_bold);
Index: libzvt/subshell.c
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/subshell.c,v
retrieving revision 1.39
retrieving revision 1.38.2.1
diff -u -r1.39 -r1.38.2.1
Index: libzvt/update.c
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/update.c,v
retrieving revision 1.72
retrieving revision 1.70.2.2
diff -u -r1.72 -r1.70.2.2
--- libzvt/update.c	11 Jun 2002 16:04:32 -0000	1.72
+++ libzvt/update.c	2 Aug 2002 01:58:16 -0000	1.70.2.2
@@ -17,6 +17,28 @@
  *  License along with this program; if not, write to the Free Software
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
+/*
+  I18N codes are added by
+	Naoyuki Ishimura <naoyuki.ishimura@sun.com>
+	Hidetoshi Tajima <hidetoshi.tajima@sun.com>
+
+   Copyright (C) 2002 Sun Microsystems, Inc.
+
+   The Gnome Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The Gnome Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the Gnome Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
 
 /*
   This module handles the update of the 'on-screen' virtual terminal
@@ -24,7 +46,6 @@
 
   It also handles selections, and making them visible, etc.
 */
-
 #include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -63,7 +84,6 @@
   /*  struct vt_line *bl;*/
   int sx, ex;			/* start/end selection */
   int force;
-
   d(printf("updating line %d: ", line));
   d(fwrite(l->data, l->width, 1, stdout));
   d(printf("\n"));
@@ -141,7 +161,6 @@
       newchar = l->data[i];
     else
       newchar = lastchar;
-
     /* check for selected block */
     if (i >= sx && i < ex) {
       newchar ^= VTATTR_REVERSE;
@@ -149,11 +168,21 @@
 
     /* used in both if cases */
     newattr = newchar & VTATTR_MASK;
-
+    
+#ifdef HAS_I18N
+    if (newchar & VTATTR_UTF16_HALF) {
+      newattr &= ~VTATTR_UTF16_HALF;
+    }
+#endif
     /* if there are no changes, quit right here ... */
     if (oldchar != newchar || force) {
       bl->data[i] = newchar;
       oldattr = oldchar & VTATTR_MASK;
+#ifdef HAS_I18N
+      if (oldchar & VTATTR_UTF16_HALF) {
+	oldattr &= ~VTATTR_UTF16_HALF;
+      }
+#endif      
       if (run) {
 	if (newattr == attr) {
 	  if (vx->back_match) {
@@ -212,7 +241,7 @@
     }
     lastchar = newchar & VTATTR_MASK;
   }
-
+  
   if (run) {
     vx->draw_text(vx->vt.user_data, bl,
 		  line, runstart, run, attr);
@@ -1002,6 +1031,67 @@
   if (start<0)
     start=0;
  
+#ifdef HAS_I18N
+  switch(size) {
+  case 4: {
+    gunichar uc;
+    gunichar *ucs4_ptr = (gunichar *)out;
+    for (i = start; i < end; i++) {
+      uc = 0;
+      if (l->data[i] & VTATTR_UTF16_HALF) {
+	uc = (l->data[i++] & VTATTR_DATAMASK) << 16;
+      }
+      uc |= l->data[i] & VTATTR_DATAMASK;
+      if (state == 0) {
+	if (uc == 0x09)
+	  state = 1;
+	else if (uc < 32)
+	  uc = ' ';
+	*ucs4_ptr++ = uc; 
+      } else {
+	if (uc) {
+	  if (uc != 0x09)
+	    state = 0;
+	  *ucs4_ptr++ = uc;
+	}
+      }
+    }
+    if (lf)
+      *ucs4_ptr++ = '\n';
+    out = (char *)ucs4_ptr; 
+  }
+  break;
+  default: {
+    /* convert to UTF-8 */
+    gunichar uc;
+    gchar *utf8_ptr = out;
+    gint utf8_len;
+    for (i = start; i < end; i++) {
+      uc = 0;
+      if (l->data[i] & VTATTR_UTF16_HALF) {
+	uc = (l->data[i++] & VTATTR_DATAMASK) << 16;
+      }
+      uc |= l->data[i] & VTATTR_DATAMASK;
+      if (state == 0) {
+	if (uc == 0x09)
+	  state = 1;
+	else if (uc < 32)
+	  uc = ' ';
+	utf8_ptr += g_unichar_to_utf8(uc, utf8_ptr);
+      } else {
+	if (uc) {
+	  if (uc != 0x09)
+	    state = 0;
+	  utf8_ptr += g_unichar_to_utf8(uc, utf8_ptr);
+	}
+      }
+    }
+    if (lf)
+      *utf8_ptr++ = '\n';
+    out = utf8_ptr;
+  }
+  }
+#else      
   /* YUCK!  oh well, this seems easiest way to do this! */
   switch(size) {
   case 2: {
@@ -1082,9 +1172,30 @@
   }
   break;
   }
+#endif /* HAS_I18N */
   return out;
 }
 
+#ifdef HAS_I18N
+gint
+vt_column_from_utf8(gchar *utf8_ptr, gint length) {
+  gunichar uc;
+  gchar *p = utf8_ptr;
+  gint count = 0;
+
+  do {
+    if (*p == 0)
+      break;
+    
+    uc = g_utf8_get_char(p);
+    if (g_unichar_iswide(uc))
+      count++;
+    count++;
+  } while ((p = g_utf8_next_char(p)) && (p - utf8_ptr) < length);
+  return count;
+}
+#endif /* HAS_I18N */
+
 /*
   select block (sx,sy)-(ex,ey) from the buffer.
 
@@ -1159,8 +1270,16 @@
       out = vt_expand_line(wn, size, 0, ex, out);
   }
 
+#ifdef HAS_I18N
+  *out = 0;
+  if (size == 1) 
+    *len = vt_column_from_utf8(data, strlen(data));
+  else
+    *len = (out - data) / size;
+#else  
   *len = (out-data)/size;
   *out = 0;
+#endif /* HAS_I18N */
 
   d(printf("selected text = \n");
     fwrite(data, out-data, 1, stdout);
@@ -1294,6 +1413,7 @@
       | ( attr & ~(VTATTR_FORECOLOURM|VTATTR_BACKCOLOURM));
     }
     vx->back_match=0;		/* forces re-draw? */
+
     vx->draw_text(vx->vt.user_data,
 		  vx->vt.this_line,
 		  vx->vt.cursory, vx->vt.cursorx, 1, attr);
Index: libzvt/vt.c
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/vt.c,v
retrieving revision 1.87
retrieving revision 1.86.2.3
diff -u -r1.87 -r1.86.2.3
--- libzvt/vt.c	3 Jun 2002 16:59:26 -0000	1.87
+++ libzvt/vt.c	2 Aug 2002 01:58:16 -0000	1.86.2.3
@@ -17,7 +17,28 @@
  *  License along with this program; if not, write to the Free Software
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
-
+/*
+  I18N codes are added by
+	Naoyuki Ishimura <naoyuki.ishimura@sun.com>
+	Hidetoshi Tajima <hidetoshi.tajima@sun.com>
+
+   Copyright (C) 2002 Sun Microsystems, Inc.
+
+   The Gnome Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The Gnome Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the Gnome Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
 /*
   This module handles the update of the 'off-screen' virtual terminal
 */
@@ -634,7 +655,11 @@
   c = l->data[vt->cursorx] & VTATTR_DATAMASK;
 
   /* dont store tab over a space - will affect attributes */
+#ifdef HAS_I18N
+  if (c == 0 && !(l->data[vt->cursorx] & VTATTR_UTF16_HALF)) {
+#else    
   if (c == 0) {
+#endif    
     /* We do not store the attribute as tabs are transparent
      * with respect to attributes
      */
@@ -1495,6 +1520,16 @@
   char *ptr_end;
   void (*process)(struct vt_em *vt);	/* process function */
 
+#ifdef HAS_I18N
+  /* convert UTF8 to UCS4 and process only 7 bit code
+   * must free ucs4 at the end of this function
+   */
+  glong i;
+  glong char_length;
+  gboolean iswide;
+  gunichar *ucs4 = g_utf8_to_ucs4_fast (ptr, length, &char_length);
+#endif /* HAS_I18N */
+
   /* states:
    *   0: normal escape mode
    *   1: escape mode.  switch on next character.
@@ -1512,9 +1547,13 @@
    */
 
   state = vt->state;
+
+#ifdef HAS_I18N
+  for (i = 0; i < char_length; i++) {
+    c = ucs4[i];
+#else    
   ptr_end = ptr + length;
   while (ptr < ptr_end) {
-
     /* convert to unsigned byte */
     c = (*ptr++) & 0xff;
 
@@ -1559,7 +1598,18 @@
     mode = modes[c & 0x7f].modes;
     process = modes[c & 0x7f].process;
 #endif /* ZVT_UTF */
+#endif /* HAS_I18N */
 
+#ifdef HAS_I18N
+    if (c <= 0x7f) {
+      mode = modes[c].modes;
+      process = modes[c].process;
+    } else {
+      mode = VT_LIT;
+      process = 0;
+    }
+#endif /* HAS_I18N */    
+	
     vt->state = state;		/* so callbacks know their state */
     
     d(printf("state %d: %d $%02x '%c'\n",state, vt->argcnt, c, isprint(c)?c:'.'));
@@ -1571,13 +1621,18 @@
 	/* remap character? */
 	if (vt->remaptable && c<=0xff)
 	  c=vt->remaptable[c];
-	
+
 	/* insert mode? */
 	if (vt->mode & VTMODE_INSERT)
 	  vt_insert_chars(vt, 1);
 	
 	/* need to wrap? */
+#ifdef HAS_I18N
+	iswide = g_unichar_iswide(c);
+	if (vt->cursorx >= vt->width - (iswide ? 1 : 0)) {
+#else	  
 	if (vt->cursorx>=vt->width) {
+#endif	  
 	  if (vt->mode&VTMODE_WRAPOFF)
 	    vt->cursorx = vt->width-1;
 	  else {
@@ -1587,7 +1642,20 @@
 	}
 	
 	/* output character */
+#ifdef HAS_I18N
+	if (iswide) {
+	  /* - this will be zero data other than UTF16 surrogate pair character
+	   * - put this to data as these characters occupy two columns   
+	   */
+	  vt->this_line->data[vt->cursorx] =
+	    ((vt->attr) & VTATTR_MASK) | VTATTR_UTF16_HALF | ((c & 0xffff0000) >> 16);
+	  vt->this_line->modcount++;
+	  vt->cursorx++;
+	}
+	vt->this_line->data[vt->cursorx] = ((vt->attr) & VTATTR_MASK) | (VTATTR_DATAMASK & c); 
+#else
 	vt->this_line->data[vt->cursorx] = ((vt->attr) & VTATTR_MASK) | c;
+#endif /* HAS_I18N */
 	vt->this_line->modcount++;
 	/* d(printf("literal %c\n", c)); */
 	vt->cursorx++;
@@ -1706,6 +1774,10 @@
   }
 
   vt->state = state;
+
+#ifdef HAS_I18N
+  g_free (ucs4);
+#endif  
 }
 
 /**
Index: libzvt/vt.h
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/vt.h,v
retrieving revision 1.31
retrieving revision 1.31.2.2
diff -u -r1.31 -r1.31.2.2
--- libzvt/vt.h	29 Nov 2001 23:56:28 -0000	1.31
+++ libzvt/vt.h	2 Aug 2002 01:58:17 -0000	1.31.2.2
@@ -18,6 +18,29 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+/*
+  I18N codes are added by
+	Naoyuki Ishimura <naoyuki.ishimura@sun.com>
+	Hidetoshi Tajima <hidetoshi.tajima@sun.com>
+
+   Copyright (C) 2002 Sun Microsystems, Inc.
+
+   The Gnome Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The Gnome Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the Gnome Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
 #ifndef _ZVT_VT_H_
 #define _ZVT_VT_H_
 
@@ -73,10 +96,16 @@
 #define VTATTR_REVERSE    0x08000000
 #define VTATTR_CONCEALED  0x04000000
 
+#ifdef HAS_I18N
+#define VTATTR_UTF16_HALF 0x80000000
+#endif
+
 /* all attributes mask, and no-attributes mask */
 #define VTATTR_MASK	  0xffff0000
 #define VTATTR_DATAMASK	  (~VTATTR_MASK)
+
 #define VTATTR_CLEARMASK  (~(VTATTR_BOLD|VTATTR_UNDERLINE|VTATTR_BLINK|VTATTR_REVERSE))
+  
 
 /* bitmasks for colour map information */
 #define VTATTR_FORECOLOURM 0x03e00000
Index: libzvt/zvtterm.c
===================================================================
RCS file: /cvs/gnome/libzvt/libzvt/zvtterm.c,v
retrieving revision 1.188
retrieving revision 1.187.2.18
diff -u -r1.188 -r1.187.2.18
--- libzvt/zvtterm.c	3 Jun 2002 16:59:26 -0000	1.188
+++ libzvt/zvtterm.c	6 Aug 2002 23:38:49 -0000	1.187.2.18
@@ -17,6 +17,47 @@
  *  License along with this program; if not, write to the Free Software
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
+
+/*
+ * Copyright (C) 2001,2002 Red Hat, Inc.
+ *
+ * This is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+/*
+  I18N codes are added by
+	Naoyuki Ishimura <naoyuki.ishimura@sun.com>
+	Hidetoshi Tajima <hidetoshi.tajima@sun.com>
+
+   Copyright (C) 2002 Sun Microsystems, Inc.
+
+   The Gnome Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The Gnome Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the Gnome Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
 #include <config.h>
 
 /* please use K&R style indenting if you make changes.
@@ -50,6 +91,10 @@
 #include <gtk/gtkselection.h>
 #include <gtk/gtkwindow.h>
 #include <gtk/gtkbindings.h>
+#ifdef HAS_I18N
+#include <gtk/gtkimmulticontext.h>
+#include <pango/pangox.h>
+#endif
 
 #include <libzvt/libzvt.h>
 
@@ -70,7 +115,11 @@
 #define d(x)
 
 /* default font */
+#ifdef HAS_I18N
+#define DEFAULT_FONT "monospace 13"
+#else
 #define DEFAULT_FONT "-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso8859-1"
+#endif
 
 #define PADDING 0
 
@@ -178,6 +227,16 @@
   GIOChannel *channel;
       
   channel = g_io_channel_unix_new (source);
+#ifdef HAS_I18N
+  {
+    /* code conversion will be done after read data
+    gchar *locale_encoding;
+    g_get_charset(&locale_encoding);
+    g_io_channel_set_encoding (channel, locale_encoding, NULL);
+    */
+    g_io_channel_set_encoding (channel, NULL, NULL);
+  }
+#endif			     
   result = g_io_add_watch (channel, condition, function, data);
   g_io_channel_unref (channel);
 
@@ -371,7 +430,7 @@
   term->vx->draw_text = vt_draw_text;
   term->vx->scroll_area = vt_scroll_area;
   term->vx->selection_changed = vt_selection_changed;
-term->vx->cursor_state = vt_cursor_state;
+  term->vx->cursor_state = vt_cursor_state;
 
   term->shadow_type = GTK_SHADOW_NONE;
   term->term_window = NULL;
@@ -385,11 +444,12 @@
   term->back_gc = NULL;
   term->fore_last = 0;
   term->back_last = 0;
-  /* Deprecated */
-  /*
-  term->color_ctx = 0;
+
+#ifdef HAS_I18N
   term->ic = NULL;
-  */
+  term->xfontset = 0;
+  term->font_ascent = 0;
+#endif  
 
   /* grid sizing */
   term->grid_width = term->vx->vt.width;
@@ -432,7 +492,7 @@
   zp->bold_save = 0;
   zp->paste_id = -1;
   zp->paste = 0;
-  
+
   zp->auto_hint = TRUE;
   
   /* background stuff */
@@ -450,7 +510,7 @@
   g_object_set_data(G_OBJECT (term), "_zvtprivate", zp);
 
   /* charwidth, charheight set here */
-  zvt_term_set_font_name (term, DEFAULT_FONT);
+  zvt_term_set_font_name (term, NULL);
 
   /* scrollback position adjustment */
   term->adjustment =
@@ -759,13 +819,14 @@
     term->adjustment = NULL;
   }
 
-  /* Deprecated */
-  /*
+#ifdef HAS_I18N
   if (term->ic) {
-    gdk_ic_destroy(term->ic);
+    g_object_unref(term->ic);
     term->ic = NULL;
   }
-  */
+  if (term->xfontset)
+    XFreeFontSet (GDK_DISPLAY(), term->xfontset);
+#endif
 
   /* release private data */
   if (zp) {
@@ -787,7 +848,17 @@
 
     if (zp->background)
 	zvt_term_background_unload (term);
-    
+
+#ifdef HAS_I18N    
+    if (zp->pango_font) {
+      pango_font_description_free(zp->pango_font);
+    }
+
+    if (zp->pango_font_bold) {
+      pango_font_description_free(zp->pango_font_bold);
+    }
+
+#endif
     g_free(zp);
    g_object_set_data (G_OBJECT (term), "_zvtprivate", 0);
   }
@@ -963,6 +1034,181 @@
     }
 }
 
+#ifdef HAS_I18N
+static void
+zvt_term_commit_handler (GtkIMContext  *context,
+			 const gchar   *str,
+			 ZvtTerm       *term)
+{
+  gsize   length = 0;
+  gchar *locstr = g_locale_from_utf8 (str, -1, NULL, &length, NULL);
+
+  if (length > 0) {
+    vt_writechild (&term->vx->vt, locstr, length);
+    if (term->scroll_on_keystroke) zvt_term_scroll (term, 0);
+  }
+  g_free (locstr);
+}
+
+static GdkWindow *zvt_make_preedit_window(GtkWidget *widget) {
+    GdkWindowAttr window_attr;
+    gint attr_mask;
+    window_attr.wclass = GDK_INPUT_OUTPUT;
+    window_attr.window_type = GDK_WINDOW_CHILD;
+    window_attr.event_mask = GDK_EXPOSURE_MASK;
+    window_attr.visual = gtk_widget_get_visual(widget);
+    window_attr.colormap = gtk_widget_get_colormap(widget);
+    attr_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
+    return gdk_window_new(widget->window, &window_attr, attr_mask);
+}
+
+static void zvt_resize_preedit_window(GdkWindow *window, gint x, gint y, ZvtTerm *term, gint width) {
+  gint space;
+
+  if (width > term->vx->vt.width)
+    width = term->vx->vt.width;
+
+  space = term->vx->vt.width - term->vx->vt.cursorx;
+  if (space < width)
+    x -= (width - space) * term->charwidth;
+
+  gdk_window_move_resize(window, x, y, width * term->charwidth, term->charheight);
+}
+
+#define PREEDIT_UNDERLINE_WIDTH 1
+
+static void
+zvt_term_preedit_changed_handler (GtkIMContext *context,
+				  ZvtTerm *term)
+{
+  gchar *preedit_string;
+  gint cursor_pos;
+  struct _vtx *vx;
+  PangoAttrList *feedback_list;
+  PangoAttrIterator *iter;
+  PangoFontDescription *attr_font;
+  GSList *attrs;
+  PangoLayout *layout;
+  GdkColor *fcolor, *bcolor;
+  struct _zvtprivate *zp = 0;
+  gint x, y, preedit_len, preedit_col_len, attr_start, attr_end, attr_length, attr_x, preedit_advanced;
+  gboolean is_reverse, is_underline;
+  struct vt_line *line;
+
+  zp = _ZVT_PRIVATE(term);
+
+  gtk_im_context_get_preedit_string (context,
+				     &preedit_string,
+				     &feedback_list,
+				     &cursor_pos);
+  
+  preedit_len = strlen(preedit_string);
+  if (preedit_string == NULL || preedit_len <= 0) {
+    if (zp->preedit_window != NULL && gdk_window_is_visible(zp->preedit_window)) {
+      gdk_window_hide(zp->preedit_window);
+    }
+    return;
+  }
+
+  if (zp->preedit_window == NULL) { 
+    /* create over the spot preedit window */
+    zp->preedit_window = zvt_make_preedit_window(GTK_WIDGET(term));
+  }
+
+  preedit_col_len = vt_column_from_utf8(preedit_string, preedit_len);
+  cursor_pos = CLAMP (cursor_pos, 0, g_utf8_strlen (preedit_string, -1));
+  
+  /* adjust size of preedit window */
+  vx = term->vx;
+  x = vx->vt.cursorx * term->charwidth + GTK_WIDGET(term)->style->xthickness + PADDING;
+  y = vx->vt.cursory * term->charheight + GTK_WIDGET(term)->style->ythickness;
+
+  zvt_resize_preedit_window(zp->preedit_window, x, y, term, preedit_col_len);
+  gdk_window_show(zp->preedit_window);
+
+  /* draw preedit string with attribute */ 
+  zp->pango_context = gdk_pango_context_get();
+  pango_context_set_language (zp->pango_context,
+			      gtk_get_default_language ());
+  gdk_pango_context_set_colormap(zp->pango_context, term->color_map);
+  pango_context_set_font_description(zp->pango_context, zp->pango_font);
+
+  layout = pango_layout_new(zp->pango_context);
+  iter = pango_attr_list_get_iterator(feedback_list);
+  attr_x = 0;
+  do {
+    gchar *preedit_tmp;
+    GSList *attr_list;
+    pango_attr_iterator_range(iter, &attr_start, &attr_end);
+    attr_end = CLAMP(attr_end, attr_start, preedit_len);
+    attr_length = attr_end - attr_start;
+    if (attr_length <= 0)
+      continue;
+
+    pango_attr_iterator_get_font(iter, attr_font, NULL, &attrs);
+    is_underline = FALSE;
+    is_reverse = FALSE;
+    attr_list = attrs;
+    while (attr_list) {
+      PangoAttribute *attr = attr_list->data;
+      switch(attr->klass->type) {
+      case PANGO_ATTR_FOREGROUND:
+	/* FIX Later: should keep color */
+	is_reverse = TRUE;
+	break;
+      case PANGO_ATTR_BACKGROUND:
+	/* FIX Later: should keep color */
+	is_reverse = TRUE;
+	break;
+      case PANGO_ATTR_UNDERLINE:
+	is_underline = TRUE;
+	break;
+      case PANGO_ATTR_STRIKETHROUGH:
+	break;
+      default:
+	g_warning("Unknown preedit attribute type: %d\n", attr->klass->type);
+	break;
+      }
+      pango_attribute_destroy(attr);
+      if(attr_list == attrs->next) {
+	break; /* why this happens.... */
+      }
+      attr_list = attrs->next;
+    }
+    pango_layout_set_text(layout, preedit_string + attr_start, attr_length);
+    if (is_reverse) {
+      gdk_draw_layout_with_colors(zp->preedit_window, term->fore_gc, attr_x, 0, layout,
+				  &(term->colors[17]), &(term->colors[16]));
+    } else {
+      gdk_draw_layout_with_colors(zp->preedit_window, term->fore_gc, attr_x, 0, layout,
+				  &(term->colors[16]), &(term->colors[17]));
+    }
+
+    preedit_advanced = vt_column_from_utf8(preedit_string + attr_start, attr_length) * term->charwidth;
+    if (is_underline) {
+      gdk_gc_set_foreground(term->fore_gc, &(term->colors[16]));
+      gdk_draw_rectangle(zp->preedit_window, term->fore_gc, 1,
+			 attr_x, term->charheight - PREEDIT_UNDERLINE_WIDTH,
+			 preedit_advanced, PREEDIT_UNDERLINE_WIDTH);
+    }
+    attr_x +=  preedit_advanced;
+  } while(pango_attr_iterator_next(iter));
+
+  pango_attr_iterator_destroy(iter);
+  g_object_unref (layout);
+  g_free (preedit_string);
+}
+
+static void
+zvt_term_im_reset (ZvtTerm *term)
+{
+  if (term->ic && term->need_im_reset) {
+    term->need_im_reset = FALSE;
+    gtk_im_context_reset (term->ic);
+  }
+}
+#endif 
+
 static void
 zvt_term_realize (GtkWidget *widget)
 {
@@ -1066,20 +1312,21 @@
   term_force_size(term);
 
   /* input context */
-#ifdef UNDEF
-  if (gdk_im_ready () && !term->ic) {
-    GdkICAttr attr;
-    
-    /* FIXME: do we have any window yet? */
-    attr.style = GDK_IM_PREEDIT_NOTHING | GDK_IM_STATUS_NOTHING;
-    attr.client_window = attr.focus_window = widget->window;
-    term->ic = gdk_ic_new(&attr, GDK_IC_ALL_REQ);
+#ifdef HAS_I18N
+  if (!term->ic) {
+    term->ic = gtk_im_multicontext_new ();
+    g_signal_connect (term->ic, "commit",
+		      G_CALLBACK (zvt_term_commit_handler), term);
+
+    gtk_im_context_set_client_window (term->ic, widget->window);
+    /* gtk_im_context_set_use_preedit(term->ic, FALSE); */
     
-    if (!term->ic) {
-      g_warning("Can't create input context.");
-    }
+    g_signal_connect (G_OBJECT(term->ic), "preedit-changed",
+		      GTK_SIGNAL_FUNC(zvt_term_preedit_changed_handler), term);
+    zp->preedit_window = NULL;
   }
-#endif /* UNDEF */
+
+#endif 
   /* if we have a delayed background set, set it here? */
   if (zp->background_queue) {
     zvt_term_background_load(term, zp->background_queue);
@@ -1129,6 +1376,11 @@
   g_object_unref (term->fore_gc);
   term->fore_gc = NULL;
 
+#ifdef HAS_I18N
+  if (term->ic)
+    gtk_im_context_set_client_window (term->ic, NULL);
+#endif  
+
   if (GTK_WIDGET_CLASS (parent_class)->unrealize)
     (*GTK_WIDGET_CLASS (parent_class)->unrealize) (widget);
 }
@@ -1190,11 +1442,12 @@
   if (term->blink_enabled && term->timeout_id == -1)
     term->timeout_id = gtk_timeout_add (500, zvt_term_cursor_blink, term);
 
-  /* Deprecated */
-  /*
-  if (term->ic)
-    gdk_im_begin (term->ic, widget->window);
-  */
+#ifdef HAS_I18N
+  if (term->ic) {
+    term->need_im_reset = TRUE;
+    gtk_im_context_focus_in (term->ic);
+  }
+#endif  
 
   return FALSE;
 }
@@ -1222,12 +1475,6 @@
     term->timeout_id = -1;
   }
   
-  /* Deprecated */
-  /*
-  if (term->ic)
-    gdk_im_end ();
-  */
-
   return FALSE;
 }
 
@@ -1361,9 +1608,14 @@
 		    (event->area.y-offy) / term->charheight,
 		    (event->area.x + event->area.width) / term->charwidth+1,
 		    (event->area.y + event->area.height) / term->charheight+1);
-
     term->in_expose = 0;
 
+#ifdef HAS_I18N
+    if (zp->preedit_window != NULL && gdk_window_is_visible(zp->preedit_window)) {
+      zvt_term_preedit_changed_handler(term->ic, term);
+    }
+#endif     
+
     if (term->shadow_type != GTK_SHADOW_NONE)
       gtk_paint_shadow (widget->style, widget->window,
 		        GTK_STATE_NORMAL, term->shadow_type, 
@@ -1437,6 +1689,7 @@
 }
 
 
+#ifndef HAS_I18N
 /* Load a set of fonts into the terminal.
  * These fonts should be the same size, otherwise it could get messy ...
 i to * if font_bold is NULL, then the font is emboldened manually (overstrike)
@@ -1504,6 +1757,7 @@
 
   gtk_widget_queue_resize (GTK_WIDGET (term));
 }
+#endif /* HAS_I18N */
 
 /**
  * zvt_term_set_fonts:
@@ -1527,10 +1781,302 @@
   if (font_bold)
       gdk_font_ref (font_bold);
   
+#ifndef HAS_I18N
   zvt_term_set_fonts_internal (term, font, font_bold);
+#endif  
+}
+
+#ifdef HAS_I18N
+/*
+  xlfd_from_pango_font_description copied from vte, which was
+  written by nalin@redhat.com, and added some codes.
+*/
+static char *
+xlfd_from_pango_font_description(GtkWidget *widget,
+				 const PangoFontDescription *fontdesc)
+{
+	char *spec;
+	PangoContext *context;
+	PangoFont *font;
+	PangoXSubfont *subfont_ids;
+	PangoFontMap *fontmap;
+	int *subfont_charsets, i, count = 0;
+	char *xlfd = NULL, *tmp, *subfont;
+	char *encodings[] = {
+		"ascii-0",
+		"big5-0",
+		"dos-437",
+		"dos-737",
+		"gb18030.2000-0",
+		"gb18030.2000-1",
+		"gb2312.1980-0",
+		"iso8859-1",
+		"iso8859-2",
+		"iso8859-3",
+		"iso8859-4",
+		"iso8859-5",
+		"iso8859-7",
+		"iso8859-8",
+		"iso8859-9",
+		"iso8859-10",
+		"iso8859-15",
+		"iso10646-0",
+		"iso10646-1",
+		"jisx0201.1976-0",
+		"jisx0208.1983-0",
+		"jisx0208.1990-0",
+		"jisx0208.1997-0",
+		"jisx0212.1990-0",
+		"jisx0213.2000-1",
+		"jisx0213.2000-2",
+		"koi8-r",
+		"koi8-u",
+		"koi8-ub",
+		"ksc5601.1987-0",
+		"ksc5601.1992-3",
+		"tis620-0",
+		"iso8859-13",
+		"microsoft-cp1251"
+		"misc-fontspecific",
+	};
+#if XlibSpecificationRelease >= 6
+	XOM xom;
+#endif
+	g_return_val_if_fail(fontdesc != NULL, NULL);
+	g_return_val_if_fail(GTK_IS_WIDGET(widget), NULL);
+
+	context = gtk_widget_get_pango_context(GTK_WIDGET(widget));
+	fontmap = pango_x_font_map_for_display(GDK_DISPLAY());
+	if (fontmap == NULL) {
+		return g_strdup("fixed");
+	}
+
+	font = pango_font_map_load_font(fontmap, context, fontdesc);
+	if (font == NULL) {
+		return g_strdup("fixed");
+	}
+
+#if XlibSpecificationRelease >= 6
+	xom = XOpenOM (GDK_DISPLAY(), NULL, NULL, NULL);
+	if (xom) {
+	  XOMCharSetList cslist;
+	  int n_encodings = 0;
+
+	  cslist.charset_count = 0;
+	  XGetOMValues (xom,
+			XNRequiredCharSet, &cslist,
+			NULL);
+	  n_encodings = cslist.charset_count;
+	  if (n_encodings) {
+	    char **xom_encodings = g_malloc (sizeof(char*) * n_encodings);
+
+	    for (i = 0; i < n_encodings; i++)
+	      xom_encodings[i] = g_ascii_strdown (cslist.charset_list[i], -1);
+	    count = pango_x_list_subfonts(font, xom_encodings, n_encodings,
+					  &subfont_ids, &subfont_charsets);
+
+	    for(i = 0; i < n_encodings; i++)
+	      g_free (xom_encodings[i]);
+	    g_free (xom_encodings);
+	  }
+	  XCloseOM (xom);
+	}
+#endif
+	if (count == 0)
+	  count = pango_x_list_subfonts(font, encodings, G_N_ELEMENTS(encodings),
+					&subfont_ids, &subfont_charsets);
+
+	for (i = 0; i < count; i++) {
+		subfont = pango_x_font_subfont_xlfd(font, subfont_ids[i]);
+		if (xlfd) {
+			tmp = g_strconcat(xlfd, ",", subfont, NULL);
+			g_free(xlfd);
+			g_free(subfont);
+			xlfd = tmp;
+		} else {
+			xlfd = subfont;
+		}
+	}
+
+	spec = pango_font_description_to_string(fontdesc);
+
+	if (subfont_ids != NULL) {
+		g_free(subfont_ids);
+	}
+	if (subfont_charsets != NULL) {
+		g_free(subfont_charsets);
+	}
+	g_free(spec);
+
+	return xlfd;
+}
+
+static const gchar *ASCII_CHARACTERS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !\"#$%&'()*+,-./:;<=>?@\\]^_`{}~";
+
+static const gchar *DEFAULT_XLFD_NAME = "-*-*-*-*-*-*-%i-*-*-*-*-*-*-*";
+
+static XFontSet
+zvt_term_get_xfontset_internal (ZvtTerm *term,
+				const char *fontset_name,
+				int *new_charwidth, 
+				int *new_charheight)
+{
+  gint  missing_charset_count;
+  gchar **missing_charset_list;
+  gchar *def_string;
+  XFontSet new_fontset = 0;
+
+  new_fontset = XCreateFontSet (GDK_DISPLAY (), fontset_name,
+				&missing_charset_list,
+				&missing_charset_count,
+				&def_string);
+  if (missing_charset_list != NULL) {
+    XFreeStringList(missing_charset_list);
+    missing_charset_list = NULL;
+  }
+
+  if (new_fontset) {
+    gint i;
+    gint max_percharwidth = 0;
+    gint max_percharheight = 0;
+    XRectangle extent;
+    gchar *bufp = (gchar*)ASCII_CHARACTERS;
+    gint char_len = strlen(bufp);
+
+    /* should be a little faster than using XmbTextPerCharExtents... */
+    for (i = 0; i < char_len; i++) {
+      if (XmbTextExtents(new_fontset, bufp++, 1,
+			 0, &extent) > 0) {
+	max_percharwidth = (extent.width > max_percharwidth ?
+			    extent.width : max_percharwidth);
+	max_percharheight = (extent.height > max_percharheight ?
+			     extent.height : max_percharheight);
+      }
+    }
+    *new_charwidth = max_percharwidth;
+    *new_charheight = max_percharheight;
+
+    if (*new_charwidth == 0 || *new_charheight == 0) {
+      if (new_fontset)
+	XFreeFontSet (GDK_DISPLAY(), new_fontset);
+      new_fontset = 0;
+    }
+  }
+  return new_fontset;
+}
+
+static void
+zvt_term_get_xfontset (ZvtTerm *term,
+		       const PangoFontDescription *font_desc)
+{
+  struct _zvtprivate *zp;
+  GtkWidget *widget;
+  gchar *fontset_name = 0;
+  XFontSet new_fontset = 0;
+  int new_charwidth = 0;
+  int new_charheight = 0;
+
+  zp = _ZVT_PRIVATE (term);
+  widget = GTK_WIDGET (term);
+
+  fontset_name = xlfd_from_pango_font_description(GTK_WIDGET(widget),
+						  font_desc);
+  if (fontset_name) {
+    new_fontset = zvt_term_get_xfontset_internal (term, fontset_name, 
+						  &new_charwidth,
+						  &new_charheight);
+    g_free(fontset_name);
+  }
+
+  if (new_fontset == 0 || new_charwidth == 0 || new_charheight == 0) {
+    guint font_size = pango_font_description_get_size(font_desc)/PANGO_SCALE;
+    g_warning ("Cannot get required fonts from \"%s %i\"",
+	       pango_font_description_get_family (font_desc),
+	       font_size);
+
+    fontset_name = g_strdup_printf (DEFAULT_XLFD_NAME, font_size);
+    g_warning ("Use \"%s\" XLFD fontname - some characters may not appear correctly\n", fontset_name);
+
+    new_fontset = zvt_term_get_xfontset_internal (term, fontset_name,
+						  &new_charwidth,
+						  &new_charheight);
+    g_free (fontset_name);
+
+    if (new_fontset == 0 || new_charwidth == 0 || new_charheight == 0) {
+      fontset_name = g_strdup_printf (DEFAULT_XLFD_NAME, 0);
+      g_warning ("Use \"%s\" XLFD fontname - some characters may not appear correctly\n", fontset_name);
+      new_fontset = zvt_term_get_xfontset_internal (term, fontset_name,
+						    &new_charwidth,
+						    &new_charheight);
+      g_free (fontset_name);
+    }
+  }
+  g_return_if_fail (new_fontset != NULL);
+  g_return_if_fail (new_charwidth != 0);
+  g_return_if_fail (new_charheight != 0);
+
+  if (term->xfontset)
+    XFreeFontSet (GDK_WINDOW_XDISPLAY(widget->window),
+		  term->xfontset);
+  term->xfontset = new_fontset;
+  term->charwidth = new_charwidth;
+  term->charheight = new_charheight;
+
+  return;
 }
 
 /**
+ * zvt_term_set_pango_font:
+ * @term: A &ZvtTerm widget.
+ * @font_desc: Pango Font used for regular text.
+ *
+ * Load pango font into the terminal.
+ * 
+ * These fonts should be the same size, otherwise it could get messy ...
+ */
+void
+zvt_term_set_pango_font (ZvtTerm *term,
+			 const PangoFontDescription *font_desc)
+{
+  PangoFontDescription *font_bold_desc;
+  PangoFontset *fontset;
+  PangoFontMetrics *metrics;
+  struct _zvtprivate *zp;
+
+  g_return_if_fail (term != NULL);
+  g_return_if_fail (ZVT_IS_TERM (term));
+  g_return_if_fail (font_desc != NULL);
+
+  zp = _ZVT_PRIVATE(term);
+  zp->pango_font = (PangoFontDescription*)font_desc;
+  
+  font_bold_desc = pango_font_description_copy(zp->pango_font);
+  pango_font_description_set_weight(font_bold_desc, PANGO_WEIGHT_BOLD);
+  zp->pango_font_bold = font_bold_desc;
+  fontset = pango_context_load_fontset(gdk_pango_context_get(),
+				       zp->pango_font, gtk_get_default_language());
+  metrics = pango_fontset_get_metrics(fontset);
+
+  gtk_widget_queue_resize (GTK_WIDGET (term));
+
+  term->font_ascent = pango_font_metrics_get_ascent(metrics)/PANGO_SCALE;
+
+  zvt_term_get_xfontset (term, font_desc);
+
+  if (term->xfontset == NULL ||
+      term->charwidth == 0 || term->charheight == 0) {
+    g_warning ("Failed to load any required font, so crash will occur.." "check X11 font pathes and etc/pangox.alias file\n");
+    pango_font_description_free(zp->pango_font);
+    pango_font_description_free(zp->pango_font_bold);
+    zp->pango_font = 0;
+    zp->pango_font_bold  = 0;
+  }
+  return;
+
+}
+#endif
+
+/**
  * zvt_term_set_font_name:
  * @term: A &ZvtTerm widget.
  * @name: A full X11 font name string.
@@ -1547,6 +2093,13 @@
 void
 zvt_term_set_font_name (ZvtTerm *term, char *name)
 {
+#ifdef HAS_I18N
+  gchar *font_name;
+
+  font_name = (name == NULL || name[0] == NULL) ? DEFAULT_FONT : name;
+  zvt_term_set_pango_font (term, 
+			   pango_font_description_from_string(font_name));
+#else  
   int count;
   char c, *ptr, *rest;
   GString *newname, *outname;
@@ -1598,6 +2151,7 @@
 
   g_string_free (newname, TRUE);
   g_string_free (outname, TRUE);
+#endif /* HAS_I18N */
 }
 
 
@@ -1635,6 +2189,12 @@
   if (text)
     {
       int i;
+#ifdef HAS_I18N
+      gsize bytes_read = 0, bytes_written;
+      gchar *buf = g_locale_from_utf8(text, strlen(text),
+				      &bytes_read, &bytes_written, NULL);
+      gint len = strlen(buf);
+#else      
       /* FIXME: pasting utf8 doesn't really work! */
       char *buf = gdk_utf8_to_string_target (text);
       int len = strlen (buf);
@@ -1642,7 +2202,8 @@
 
       for(i = 0; i < len; i++)
 	if(ctmp[i] == '\n') ctmp[i] = '\r';
-
+#endif /* HAS_I18N */
+      
       if (term->scroll_on_keystroke)
 	zvt_term_scroll (term, 0);
       zvt_term_writechild(term, buf, len);
@@ -1690,6 +2251,9 @@
 
   zvt_term_show_pointer (term);
 
+#ifdef HAS_I18N
+  zvt_term_im_reset (term);
+#endif  
 
   gdk_window_get_pointer(widget->window, &x, &y, &mask);
   x /= term->charwidth;
@@ -2076,6 +2640,24 @@
 static char *
 zvt_term_convert_selection(ZvtTerm *term, int type, int *outlen)
 {
+#ifdef HAS_I18N
+  switch (type) {
+  case 1: /* already converted */
+    *outlen = term->vx->selection_size;
+    return (gchar *)term->vx->selection_data;
+  default: {
+      /* max size of utf16 range UTF-8 is 4 */
+      gchar *utf8_ptr = g_malloc(term->vx->selection_size * 4);
+      gint i, expand_index = 0;
+      for (i = 0; i < term->vx->selection_size; i++) {
+	expand_index += g_unichar_to_utf8(term->vx->selection_data[i], &utf8_ptr[expand_index]);
+      }
+      utf8_ptr[expand_index] = '\0';
+      *outlen = expand_index;
+      return utf8_ptr;
+    }
+  }
+#else
   char *out;
   int i;
   uint32 c;
@@ -2156,8 +2738,8 @@
     break;
   }
   }
-
   return out;
+#endif
 }
 #endif
 
@@ -2264,6 +2846,7 @@
 static gint
 zvt_term_cursor_blink(gpointer data)
 {
+  /* NAOYUKI
   ZvtTerm *term;
   GtkWidget *widget;
 
@@ -2276,7 +2859,7 @@
 
   term->cursor_blink_state ^= 1;
   vt_cursor_state(data, term->cursor_blink_state);
-
+  */
   return TRUE;
 }
 
@@ -2510,7 +3093,16 @@
   if(!gtk_bindings_activate(GTK_OBJECT(widget),
                             event->keyval,
                             event->state)){
-  
+
+#ifdef HAS_I18N
+    if (term->ic) {
+      if (gtk_im_context_filter_keypress (term->ic, event)) {
+	term->need_im_reset = TRUE;
+	return TRUE;
+      }
+    }
+#endif    
+
   switch (event->keyval) {
   case GDK_BackSpace:
     if (term->backspace_binding == ZVT_ERASE_CONTROL_H ||
@@ -2711,6 +3303,9 @@
   if (handled && p>buffer) {
     vt_writechild(&vx->vt, buffer, (p-buffer));
     if (term->scroll_on_keystroke) zvt_term_scroll (term, 0);
+#ifdef HAS_I18N
+    zvt_term_im_reset (term);
+#endif
   }
   }
 
@@ -2909,15 +3504,28 @@
 zvt_term_readdata (GIOChannel *source, GIOCondition condition, gpointer data)
 {
   gboolean update;
+#ifndef HAS_I18N  
   gchar buffer[4096];
-  gint count, saveerrno;
+#endif  
+  gsize count, saveerrno;
   struct _vtx *vx;
   ZvtTerm *term;
+#ifdef HAS_I18N
+  GIOStatus io_status;
+  GError *io_error = NULL;
+  G_CONST_RETURN char *locale_encoding;
+  gchar buf[4096];
+  gchar *buffer;
+  gsize bytes_read;
+  gsize bytes_written;
+  gboolean no_need_convert = FALSE;
+#else
   gint fd;
 
   d( printf("zvt_term_readdata\n") );
 
   fd = g_io_channel_unix_get_fd (source);
+#endif /* HAS_I18N */
   term = (ZvtTerm *) data;
 
   if (term->input_id == -1)
@@ -2930,7 +3538,47 @@
 
   vt_cursor_state (term, 0);
   vt_match_highlight(term->vx, 0);
-  while ( (saveerrno == EAGAIN) && (count = read (fd, buffer, 4096)) > 0)  {
+#ifdef HAS_I18N
+  no_need_convert = g_get_charset(&locale_encoding);
+
+  while (G_IO_STATUS_EOF !=
+	 (io_status = g_io_channel_read_chars(source, buf, 4096,
+					      &count, &io_error))) {
+    if (io_status == G_IO_STATUS_ERROR) {
+      if (io_error != NULL)
+	g_warning("%s\n", io_error->message);
+
+      io_error = NULL;
+      g_io_channel_flush(source, &io_error);
+      io_error = NULL;
+      break;
+    } else if (io_status == G_IO_STATUS_AGAIN) {
+      break;
+    }
+    io_error = NULL;
+
+    if (no_need_convert)
+      buffer = g_strdup (buf);
+    else {
+      buffer = g_locale_to_utf8(buf, count,
+				&bytes_read, &bytes_written,
+				&io_error);
+      if (io_error != NULL) {
+	/* g_warning("%s\n", io_error->message); */
+	if (bytes_read > 0) {
+	  io_error = NULL;
+	  buffer = g_locale_to_utf8(buf, bytes_read,
+				    &bytes_read, &bytes_written,
+				    &io_error);
+	}
+      }
+      if (buffer == NULL)
+	buffer = g_strdup (buf);
+      if (buffer == NULL)
+	break;
+      count =  strlen(buffer);
+    }
+#endif
     update = TRUE;
     saveerrno = errno;
     vt_parse_vt (&vx->vt, buffer, count);
@@ -2938,8 +3586,10 @@
     if (g_signal_has_handler_pending(G_OBJECT(term),
 				   term_signals[GOT_OUTPUT], 0, TRUE))
 	zvt_term_got_output(term, buffer, count);
-  }
 
+    g_free (buffer);
+    buffer = NULL;
+  }
   if (update) {
     if (GTK_WIDGET_DRAWABLE (term)) {
       d( printf("zvt_term_readdata: update from read\n") );
@@ -3182,6 +3832,21 @@
 			      term->charheight - 2);
 	}
       }
+#ifdef HAS_I18N
+      /* 
+	 Some input methods may use this position to show their
+	 status-bar and lookup-choice windows.
+	 Adding +1 offset to both cursorx and cursory to keep
+	 these windows from hiding the text at the cursor location.
+       */
+      if (term->ic) {
+	GdkRectangle area;
+	area.x = (term->vx->vt.cursorx + 1) * term->charwidth;
+	area.y = (term->vx->vt.cursory + 1) * term->charheight;
+	area.width = area.height = 0;
+	gtk_im_context_set_cursor_location(term->ic, &area);
+      }
+#endif
       term->cursor_on = state;
     }
   }
@@ -3207,7 +3872,6 @@
   uint32 c;
   struct _zvtprivate *zp=0;
 
-  
   widget = user_data;
 
   g_return_if_fail (widget != NULL);
@@ -3223,12 +3887,31 @@
   if (len+col>vx->vt.width)
     len = vx->vt.width-col;
 
+#ifdef HAS_I18N
+  if (col > 0 && g_unichar_iswide(line->data[col] & VTATTR_DATAMASK)) {
+    col--;
+    len++;  
+  }
+#endif
+  
+  zp = _ZVT_PRIVATE(term);
+
   /* rendering offsetx */
   x = col * term->charwidth;
+#ifdef HAS_I18N
+
+#ifdef USE_PANGO_LAYOUT
+  /* pango origin does not need to be added ascent */
+  y = row * term->charheight;
+#else
+  y = row * term->charheight + term->font_ascent;
+#endif
+
+#else
   y = row * term->charheight + term->font->ascent;
+#endif  
   offx = widget->style->xthickness + PADDING;
   offy = widget->style->ythickness;
-  zp = _ZVT_PRIVATE(term);
 
   if (attr & VTATTR_BOLD)  {
     or = 8;
@@ -3344,9 +4027,153 @@
   /* make sure we have the space to expand the text */
   if (zp->text_expand==0 || zp->text_expandlen<len) {
     zp->text_expand = g_realloc(zp->text_expand, len*sizeof(uint32));
+    memset(zp->text_expand, 0, len *sizeof(uint32));
     zp->text_expandlen = len;
   }
 
+#ifdef HAS_I18N
+  {
+#ifdef USE_PANGO_LAYOUT
+    PangoLayout *layout;
+#endif
+    gchar *utf8_ptr = zp->text_expand;
+    glong read_count, write_count, i, utf8_len, expand_index = 0;
+    GdkColor *fcolor = &(term->colors[fore]);
+    GdkColor *bcolor = &(term->colors[back]);
+
+    for (i = col; i < col + len; i++) {
+      gunichar uc = line->data[i] & VTATTR_DATAMASK;
+      if (uc == 0 && !((line->data[i] & VTATTR_MASK) & VTATTR_UTF16_HALF)) {
+	utf8_len = 1;
+	utf8_ptr[expand_index] = ' ';
+      } else if (uc == '\t') {
+	utf8_len = 1;
+	utf8_ptr[expand_index] = ' ';
+      } else {
+	if (line->data[i] & VTATTR_UTF16_HALF) {
+	  uc = (((uc << 16) & 0xffff0000) | (line->data[++i] & VTATTR_DATAMASK));
+	}
+	utf8_len = g_unichar_to_utf8 (uc, &(utf8_ptr[expand_index]));
+      }
+      expand_index += utf8_len;
+    }
+
+#ifdef USE_PANGO_LAYOUT
+    zp->pango_context = gdk_pango_context_get();
+    pango_context_set_language (zp->pango_context,
+				gtk_get_default_language ());
+    gdk_pango_context_set_colormap(zp->pango_context, term->color_map);
+    pango_context_set_font_description(zp->pango_context, zp->pango_font);
+    layout = pango_layout_new(zp->pango_context);
+    pango_layout_set_text(layout, utf8_ptr, expand_index);
+
+    if (dofill) {
+      gdk_draw_layout_with_colors(widget->window, fgc, x + offx, y + offy, layout, fcolor, bcolor);
+    } else {
+      gdk_draw_layout(widget->window, fgc, x + offx, y + offy, layout);
+    }
+
+    g_object_unref (layout);
+#else
+    if (utf8_ptr) {
+      GError *error = NULL;
+      gsize locale_format_len = 0;
+      gchar *locale_format;
+      G_CONST_RETURN char *locale_encoding;
+
+      if (g_get_charset(&locale_encoding)) {
+	locale_format = g_strdup(utf8_ptr);
+	locale_format_len = expand_index;
+      } else
+	locale_format = g_locale_from_utf8 (utf8_ptr, expand_index, NULL,
+					    &locale_format_len, &error);
+
+      if (error) 
+	{
+	  g_warning ("Error converting from utf8: %s\n", error->message);
+	  if (error)
+	    g_error_free (error);
+	}
+      else
+	{
+	  if (term->xfontset) {
+	    /* call XmbDrawString here with XFontSet */
+	  
+	    gdk_window_get_internal_paint_info(widget->window,
+					       &real_drawable,
+					       &real_offx,&real_offy);
+	    offx-=real_offx;
+	    offy-=real_offy;
+
+#define GET_VALUE_MASK	(GCFunction | GCForeground | GCBackground | GCFillStyle)
+	    {
+	      int startx = offx + x;
+	      gchar locale_char;
+	      gchar *bufp = locale_format;
+	      gchar *endp = locale_format + locale_format_len;
+	      int mb_len;
+
+	      Display *display = GDK_WINDOW_XDISPLAY(widget->window);
+	      Drawable drawable = GDK_WINDOW_XWINDOW(real_drawable);
+	      XGCValues  values;
+	      GC gc = XCreateGC(display, drawable, 0, NULL);
+
+	      XGetGCValues(display, GDK_GC_XGC(fgc),
+			   GET_VALUE_MASK, &values);
+
+	      XSetFunction(display, gc, GXcopy);
+	      XSetFillStyle(display, gc, FillSolid);
+	      XSetForeground(display, gc, values.background);
+
+	      while (bufp < endp && (mb_len = mblen(bufp, MB_CUR_MAX)) > 0) {
+		/* draw one multi-byte character at a time, with fill
+		   if we can */
+		int text_width, spacing;
+		XRectangle extent;
+		/* fill spacing to the next character if any */
+		text_width = XmbTextExtents(term->xfontset, bufp, mb_len,
+					    0, &extent);
+		spacing = term->charwidth * (mb_len > 1 ? 2 : 1) - extent.width;
+
+		if (dofill) {
+		  XmbDrawImageString(GDK_WINDOW_XDISPLAY(widget->window),
+				     GDK_WINDOW_XWINDOW(real_drawable),
+				     term->xfontset, GDK_GC_XGC(fgc),
+				     startx, offy + y,
+				     bufp, mb_len);
+		} else {
+		  XmbDrawString(GDK_WINDOW_XDISPLAY(widget->window),
+				GDK_WINDOW_XWINDOW(real_drawable),
+				term->xfontset, GDK_GC_XGC(fgc),
+				startx, offy + y,
+				bufp, mb_len);
+		}
+		if (dofill && spacing > 0)
+		  XFillRectangle(GDK_WINDOW_XDISPLAY(widget->window),
+				 drawable,
+				 gc, startx + extent.width,
+				 offy + y + extent.y,
+				 spacing, extent.height);
+		if (overstrike)
+		  XmbDrawString(GDK_WINDOW_XDISPLAY(widget->window),
+				GDK_WINDOW_XWINDOW(real_drawable),
+				term->xfontset, GDK_GC_XGC(fgc),
+				startx, offy + y,
+				bufp, mb_len);
+		startx += term->charwidth * (mb_len > 1 ? 2 : 1);
+		bufp += mb_len;
+	      }
+	      XFreeGC(display, gc);
+	    }
+	    offx+=real_offx;
+	    offy+=real_offy;
+	  }
+	}
+      g_free (locale_format);
+    }
+#endif /* !USE_PANGO_LAYOUT */
+  }
+#else  
   /* This funtion is provided so that we can get hokked up with the 
   real_drawable used when backing store is used, which seems to be the 
   case here, when using backing store the direct X calls needs protection
@@ -3436,6 +4263,7 @@
   }
   offx+=real_offx;
   offy+=real_offy;
+#endif /* HAS_I18N */
 
   /* check for underline */
   if (attr&VTATTR_UNDERLINE) {
Index: po/.cvsignore
===================================================================
RCS file: po/.cvsignore
diff -N po/.cvsignore
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ po/.cvsignore	18 Apr 2001 16:07:50 -0000	1.1
@@ -0,0 +1,9 @@
+*.gmo
+*.mo
+Makefile
+Makefile.in
+Makefile.in.in
+POTFILES
+cat-id-tbl.c
+stamp-cat-id
+messages
Index: po/ChangeLog
===================================================================
RCS file: po/ChangeLog
diff -N po/ChangeLog
Index: po/POTFILES.in
===================================================================
RCS file: po/POTFILES.in
diff -N po/POTFILES.in
